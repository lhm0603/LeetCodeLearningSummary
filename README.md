## 组成最大数

小组中每位都有一张卡片，卡片上是6位内的正整数，将卡片连起来可以组成多种数字，计算组成的最大数字。

* 输入描述:

  “,”号分割的多个正整数字符串，不需要考虑非数字异常情况，小组最多25个人

* 输出描述:

  最大的数字字符串

**示例1**

```
输入
22,221

输出
22221
```

**示例2**

```
输入
4589,101,41425,9999

输出
9999458941425101
```

> 对题目的理解：
>
> 1. 按字符串自然大小排序之后，数字字符从大到小依次为9>8>7...3>2>1。
> 2. 且 字符串“89”要大于“723”，因为字符串自然排序匹配规则是根据第一个字符比较大小，若相等，则比较下一个，超出部分摄取比对。
> 3. 所以只需要对输入的所有数字字符串进行排序，之后按顺序输出即可！
>
> 解：
>
> ```java
> public class Main {
>     public static void main(String[] args) {
>         Scanner input = new Scanner(System.in);
>         String content = input.next();
>         String[] split = content.split(",");
>         Arrays.sort(split);
>         for (int i = split.length - 1; i >= 0; i--) {
>             System.out.print(split[i]);
>         }
>     }
> }
> ```



## 猴子爬山

一天一只顽猴想去从山脚爬到山顶，途中经过一个有个N个台阶的阶梯，但是这猴子有一个习惯： 每一次只能跳1步或跳3步，试问猴子通过这个阶梯有多少种不同的跳跃方式？

* 输入描述:

  输入只有一个整数N（0<N<=50）此阶梯有多少个阶梯

* 输出描述:

  输出有多少种跳跃方式（解决方案数）

 

**示例1：**

```
输入
50

输出
122106097
```



**示例2：**

```
输入
3

输出
2
```

> 对题目的理解：
>
> 1. 分析规律：
>
>    ```
>    台阶个数，对应跳跃方案数
>    0个台阶，有1个方案。那就是不跳
>    1个台阶，有1个方案。跳1个台阶（1）
>    2个台阶，有1个方案。一个一个跳，跳两次（12）
>    3个台阶，有2个方案。一个一个跳，跳三次。以及一次性跳三阶（123,3）
>    4个台阶，有3个方案。（1234,14,34）
>    5个台阶，有4个方案。（12345,125,145,345）
>    6个台阶，有6个方案。（123456,1236,1256,1456,3456,36）
>    7个台阶，有9个方案。（123456789....369)
>    
>    发现规律
>    1、台阶数n小于3时，都只有一种方案。
>    2、台阶数n大于等于3时，跳跃方案恰好等于(n-1)的台阶方案数+(n-3)的台阶方案数。例如：
>    台阶n=6的方案数等于5的台阶方案数+3的台阶方案数。
>    ```
>
>    解：
>
>    ```java
>    public class Main {
>        public static void main(String[] args) {
>            Scanner input = new Scanner(System.in);
>            int num = input.nextInt();
>            int count = cal(num);
>            System.out.println(count);
>        }
>    
>        private static int cal(int num) {
>            if (num < 3) {
>                return 1;
>            }
>            return cal(num - 1) + cal(num - 3);
>        }
>    
>        //台阶数：0  1  2  3  4  5  6  7  8  9
>        //方案数：1  1  1  2  3  4  6  9  13 19
>    }
>    ```